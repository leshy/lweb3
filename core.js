// Generated by CoffeeScript 1.9.3
(function() {
  var Backbone, _, bus, channel, channelHost, core, h, helpers, motherShip, protocol, protocolHost, server, startTime, subscriptionMan, v, validator,
    slice = [].slice;

  _ = require('underscore');

  Backbone = require('backbone4000/extras');

  h = helpers = require('helpers');

  subscriptionMan = require('subscriptionman2');

  validator = require('validator2-extras');

  v = validator.v;

  startTime = new Date().getTime();

  core = exports.core = subscriptionMan.fancy.extend4000({
    mergers: [Backbone.metaMerger.chainF('end')],
    log: function() {
      var args, data, msg, tags;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.verbose) {
        msg = args.shift();
        data = args.shift();
        tags = args;
        console.log(msg, tags.join(','), data);
      }
      if (this.logger) {
        if (args.length === 1) {
          args.push(void 0);
        }
        args.push('lweb');
        args.push(this.get('name'));
        return this.logger.log.apply(this.logger, args);
      }
    },
    initialize: function(options) {
      this.set(options);
      if (this.get('verbose')) {
        this.verbose = true;
      }
      this.when('parent', (function(_this) {
        return function(parent) {
          _this.parent = parent;
          if (_this.parent.verbose) {
            _this.verbose = true;
          }
          if ((_this.logger == null) && _this.logger !== false && _this.parent.logger) {
            return _this.set({
              logger: _this.parent.logger.child()
            });
          }
        };
      })(this));
      return this.when('logger', (function(_this) {
        return function(logger) {
          return _this.logger = logger;
        };
      })(this));
    },
    name: function() {
      if (this.parent) {
        return this.parent.name() + "-" + this.get('name');
      } else {
        return this.get('name') || 'noname';
      }
    },
    end: function() {
      if (this.ended) {
        return;
      } else {
        this.ended = true;
      }
      this.log('ending', {}, 'end');
      return this.trigger('end');
    }
  });

  protocolHost = exports.protocolHost = core.extend4000({
    initialize: function() {
      return this.protocols = {};
    },
    hasProtocol: function(protocol) {
      if (typeof protocol === 'function') {
        return Boolean(this[protocol.prototype.defaults.name]);
      }
      if (typeof protocol === 'object') {
        return Boolean(this[protocol.name()]);
      }
      throw new Error("what is this?");
    },
    addProtocol: function(protocol) {
      var name;
      if (!(name = protocol.name())) {
        throw new Error("what is this?");
      }
      if (this.hasProtocol(protocol)) {
        return;
      }
      _.map(protocol.requires, (function(_this) {
        return function(dependancyProtocol) {
          if (!_this.hasProtocol(dependancyProtocol)) {
            return _this.addProtocol(new dependancyProtocol());
          }
        };
      })(this));
      this[name] = protocol;
      protocol.set({
        parent: this
      });
      if (protocol.functions) {
        return _.extend(this, protocol.functions());
      }
    }
  });

  bus = exports.bus = protocolHost.extend4000(Backbone.Tagged, {
    send: function() {
      throw 'not implemented';
    },
    addTag: function() {
      throw 'not implemented';
    },
    delTag: function() {
      throw 'not implemented';
    }
  });

  channel = exports.channel = protocolHost.extend4000({
    initialize: function() {
      return this.realm = this.getRealm();
    },
    send: function(msg) {
      throw 'not implemented';
    },
    getRealm: function() {
      return {
        client: this
      };
    }
  });

  protocol = exports.protocol = core.extend4000({
    requires: []
  });

  channelHost = exports.channelHost = Backbone.Model.extend4000({
    initialize: function() {
      var channelClass;
      if (!this.defaultChannelClass) {
        this.defaultChannelClass = this.get('defaultChannelClass');
      }
      if (channelClass = this.get('channelClass') || this.channelClass) {
        return this.channelClass = this.defaultChannelClass.extend4000(channelClass);
      } else {
        return this.channelClass = this.defaultChannelClass;
      }
    }
  });

  server = exports.server = protocolHost.extend4000(channelHost, {
    channelName: function() {
      return this.idCounter++;
    },
    initialize: function() {
      this.idCounter = 1;
      return this.clients = this.children = {};
    },
    receiveConnection: function(channel) {
      var name;
      name = channel.get('name');
      this.listenTo(channel, 'change:name', (function(_this) {
        return function(channel, newname) {
          delete _this.clients[name];
          _this.clients[newname] = channel;
          return _this.trigger('connect:' + newname, channel);
        };
      })(this));
      this.listenToOnce(channel, 'end', (function(_this) {
        return function() {
          _this.stopListening(channel);
          return delete _this.clients[name];
        };
      })(this));
      this.clients[name] = channel;
      this.trigger('connect:' + name, channel);
      this.trigger('connect', channel);
      return channel;
    }
  });

  motherShip = exports.motherShip = function(name) {
    var model;
    model = {};
    model.initialize = function() {
      return this[name + "s"] = {};
    };
    model[name] = function(instanceName, attributes) {
      var instance, instanceClass;
      if (attributes == null) {
        attributes = {};
      }
      if (instance = this[name + "s"][instanceName]) {
        return instance;
      }
      instanceClass = this.get(name + "Class");
      if (!instanceClass) {
        throw "I don't have " + name + "Class defined";
      }
      instance = this[name + "s"][instanceName] = new instanceClass(_.extend({
        parent: this,
        name: instanceName
      }, attributes));
      instance.once('end', (function(_this) {
        return function() {
          return delete _this[name + "s"][instanceName];
        };
      })(this));
      this.trigger('new' + helpers.capitalize(name), instance);
      return instance;
    };
    return Backbone.Model.extend4000(model);
  };

}).call(this);
