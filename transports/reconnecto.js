// Generated by LiveScript 1.4.0
(function(){
  var Backbone, h, core, _, memBuffer, reconnecto;
  Backbone = require('backbone4000');
  h = require('helpers');
  core = require('../core');
  _ = require('underscore');
  memBuffer = exports.memBuffer = Backbone.Model.extend4000({
    initialize: function(){
      return this.buffer = [];
    },
    push: function(it){
      return this.buffer.push(it);
    },
    shift: function(){
      return this.buffer.shift();
    },
    empty: function(){
      return !this.buffer.length;
    }
  });
  reconnecto = exports.reconnecto = core.channel.extend4000(core.channelHost, {
    defaults: {
      name: 'reconnecto',
      bufferClass: memBuffer,
      autoconnect: true
    },
    initialize: function(){
      var bufferClass, this$ = this;
      bufferClass = this.get('bufferClass');
      this.buffer = new bufferClass();
      this.connected = false;
      this.cnt = 0;
      if (this.get('autoconnect')) {
        return _.defer(function(){
          return this$.connect();
        });
      }
    },
    connect: function(){
      var this$ = this;
      this.log('connect');
      if (this.channel) {
        this.stopListening(this.channel);
      }
      this.channel = new this.channelClass({
        name: 'r-' + this.cnt++,
        parent: this
      });
      this.listenTo(this.channel, 'disconnect', function(){
        return this$.reconnect();
      });
      return this.listenTo(this.channel, 'connect', function(){
        this$.log('connected');
        this$.connected = true;
        return this$.emptyBuffer();
      });
    },
    emptyBuffer: function(){
      if (this.buffer.empty()) {
        return;
      }
      if (this.send(this.buffer.shift())) {
        return this.emptyBuffer();
      }
    },
    reconnect: function(){
      var this$ = this;
      this.log('reconnect');
      this.connected = false;
      return h.wait(1000, function(){
        return this$.connect();
      });
    },
    send: function(msg){
      if (this.connected) {
        this.channel.send(msg);
        return true;
      } else {
        this.buffer.push(msg);
        return false;
      }
    }
  });
}).call(this);
