// Generated by CoffeeScript 1.9.1
(function() {
  var Backbone, _, channel, client, clientCollection, collectionInterface, collectionProtocol, core, helpers, query, queryToCallback, server, serverCollection, serverServer, subscriptionMan, v, validator;

  _ = require('underscore');

  Backbone = require('backbone4000');

  helpers = require('helpers');

  subscriptionMan = require('subscriptionman2');

  validator = require('validator2-extras');

  v = validator.v;

  core = require('../core');

  channel = require('./channel');

  query = require('./query');

  collectionInterface = core.core.extend4000({});

  collectionProtocol = core.protocol.extend4000(core.motherShip('collection'), {
    functions: function() {
      return {
        collection: _.bind(this.collection, this),
        collections: this.collections
      };
    }
  });

  queryToCallback = function(callback) {
    return function(msg, end) {
      return callback(msg.err, msg.data);
    };
  };

  clientCollection = exports.clientCollection = collectionInterface.extend4000({
    initialize: function() {
      return this.parent.parent.channel(this.get('name')).join((function(_this) {
        return function(msg) {
          return _this.event(msg);
        };
      })(this));
    },
    subscribeModel: function(id, callback) {
      return this.parent.parent.channel(this.get('name') + ":" + id).join(function(msg) {
        return callback(msg);
      });
    },
    query: function(msg, callback) {
      msg.collection = this.get('name');
      return this.parent.parent.query(msg, callback);
    },
    create: function(data, callback) {
      this.log('create', data);
      delete data._t;
      return this.query({
        create: data
      }, queryToCallback(callback));
    },
    findOne: function(pattern, callback) {
      return this.query({
        findOne: pattern
      }, queryToCallback(callback));
    },
    update: function(pattern, data, callback) {
      return this.query({
        update: pattern,
        data: data
      }, queryToCallback(callback));
    },
    fcall: function(name, args, pattern, callback) {
      return this.query({
        call: name,
        args: args,
        pattern: pattern
      }, queryToCallback(callback));
    },
    find: function(pattern, limits, callback, callbackDone) {
      query = {
        find: pattern
      };
      if (limits) {
        query.limits = limits;
      }
      return this.query(query, function(msg, end) {
        if (end) {
          return helpers.cbc(callbackDone, null, end);
        }
        return callback(null, msg);
      });
    }
  });

  client = exports.client = collectionProtocol.extend4000({
    defaults: {
      name: 'collectionClient',
      collectionClass: clientCollection
    },
    requires: [channel.client]
  });

  serverCollection = exports.serverCollection = collectionInterface.extend4000({
    initialize: function() {
      var c, callbackToRes, name;
      c = this.c = this.get('collection');
      this.c.on('update', (function(_this) {
        return function(data) {
          var id;
          if (id = data.id) {
            return _this.parent.parent.channel(_this.get('name') + ":" + id).broadcast({
              action: 'update',
              update: data
            });
          }
        };
      })(this));
      this.c.on('remove', (function(_this) {
        return function(data) {
          var id;
          if (id = data.id) {
            return _this.parent.parent.channel(_this.get('name') + ":" + id).broadcast({
              action: 'remove'
            });
          }
        };
      })(this));
      this.c.on('create', (function(_this) {
        return function(data) {
          return _this.parent.parent.channel(name).broadcast({
            action: 'create',
            create: data
          });
        };
      })(this));
      this.set({
        name: name = c.get('name')
      });
      this.when('parent', (function(_this) {
        return function(parent) {
          return parent.parent.onQuery({
            collection: name
          }, function(msg, res, realm) {
            var ref;
            if (realm == null) {
              realm = {};
            }
            _this.event(msg, res, realm);
            return (ref = _this.core) != null ? ref.event(msg.payload, msg.id, realm) : void 0;
          });
        };
      })(this));
      callbackToRes = function(res) {
        return function(err, data) {
          if (err != null ? err.name : void 0) {
            err = err.name;
          }
          return res.end({
            err: err,
            data: data
          });
        };
      };
      this.subscribe({
        create: Object
      }, function(msg, res, realm) {
        return c.createModel(msg.create, realm, callbackToRes(res));
      });
      this.subscribe({
        update: Object,
        data: Object
      }, function(msg, res, realm) {
        return c.updateModel(msg.update, msg.data, realm, callbackToRes(res));
      });
      this.subscribe({
        findOne: Object
      }, function(msg, res, realm) {
        return c.findModel(msg.findOne, function(err, model) {
          if (err) {
            return callbackToRes(res)(err);
          }
          model.render(realm, callbackToRes(res));
          if (model.gCollect) {
            return model.gCollect();
          }
        });
      });
      this.subscribe({
        call: String,
        pattern: Object,
        args: v()["default"]([]).Array()
      }, function(msg, res, realm) {
        return c.fcall(msg.call, msg.args, msg.pattern, realm, callbackToRes(res), function(err, data) {
          if (err != null ? err.name : void 0) {
            err = err.name;
          }
          return res.write({
            err: err,
            data: data
          });
        });
      });
      return this.subscribe({
        find: Object
      }, (function(_this) {
        return function(msg, res, realm) {
          var bucket, endCb;
          bucket = new helpers.parallelBucket();
          endCb = bucket.cb();
          c.findModels(msg.find, msg.limits || {}, (function(err, model) {
            var bucketCallback;
            bucketCallback = bucket.cb();
            return model.render(realm, function(err, data) {
              if (!err) {
                res.write(data);
              }
              if (model.gCollect) {
                model.gCollect();
              }
              return bucketCallback();
            });
          }), (function(err, data) {
            return endCb();
          }));
          return bucket.done(function(err, data) {
            return res.end();
          });
        };
      })(this));
    }
  });

  server = exports.server = collectionProtocol.extend4000({
    defaults: {
      name: 'collectionServer',
      collectionClass: serverCollection
    },
    requires: [channel.server]
  });

  serverServer = exports.serverServer = collectionProtocol.extend4000({
    defaults: {
      name: 'collectionServerServer',
      collectionClass: serverCollection
    },
    requires: [query.serverServer],
    initialize: function() {
      return this.when('parent', (function(_this) {
        return function(parent) {
          parent.on('connect', function(client) {
            return client.addProtocol(new server({
              verbose: _this.verbose,
              core: _this
            }));
          });
          return _.map(parent.clients, function(client, id) {
            return client.addProtocol(new server({
              verbose: _this.verbose,
              core: _this
            }));
          });
        };
      })(this));
    }
  });

}).call(this);
