// Generated by LiveScript 1.4.0
(function(){
  var _, Backbone, h, helpers, async, subscriptionMan, validator, v, core, channel, query, colors, collectionInterface, collectionProtocol, callbackToQuery, queryToCallback, clientCollection, client, serverCollection, server, serverServer;
  _ = require('underscore');
  Backbone = require('backbone4000');
  h = helpers = require('helpers');
  async = require('async');
  subscriptionMan = require('subscriptionman2');
  validator = require('validator2-extras');
  v = validator.v;
  core = require('../core');
  channel = require('./channel');
  query = require('./query');
  colors = require('colors');
  collectionInterface = core.core.extend4000({});
  collectionProtocol = core.protocol.extend4000(core.motherShip('collection'), {
    functions: function(){
      return {
        collection: _.bind(this.collection, this),
        collections: this.collections
      };
    }
  });
  callbackToQuery = query.callbackToQuery;
  queryToCallback = query.queryToCallback;
  clientCollection = exports.clientCollection = collectionInterface.extend4000({
    initialize: function(){
      var this$ = this;
      if (this.get('autosubscribe') !== false) {
        return this.parent.parent.channel(this.get('name')).join(function(msg){
          return this$.event(msg);
        });
      }
    },
    subscribeModel: function(id, callback){
      var this$ = this;
      this.parent.parent.channel(this.get('name') + ":" + id).join(function(msg){
        return callback(msg);
      });
      return function(){
        return this$.parent.parent.channel(this$.get('name') + ":" + id).part();
      };
    },
    query: function(msg, callback){
      msg.collection = this.get('name');
      return this.parent.parent.query(msg, callback);
    },
    create: function(data, callback){
      delete data._t;
      return this.query({
        create: data
      }, queryToCallback(callback));
    },
    remove: function(pattern, callback){
      return this.query({
        remove: pattern
      }, queryToCallback(callback));
    },
    findOne: function(pattern, callback){
      return this.query({
        findOne: pattern
      }, queryToCallback(callback));
    },
    update: function(pattern, data, callback){
      return this.query({
        update: pattern,
        data: data
      }, queryToCallback(callback));
    },
    fcall: function(name, args, pattern, callback){
      return this.query({
        call: name,
        args: args,
        pattern: pattern
      }, queryToCallback(callback));
    },
    find: function(pattern, limits, callback, callbackDone){
      var query;
      query = {
        find: pattern
      };
      if (limits) {
        query.limits = limits;
      }
      return this.query(query, function(msg, end){
        if (end) {
          return helpers.cbc(callbackDone, null, end);
        }
        return callback(null, msg);
      });
    }
  });
  client = exports.client = collectionProtocol.extend4000({
    defaults: {
      name: 'collectionClient',
      collectionClass: clientCollection
    },
    requires: [channel.client]
  });
  serverCollection = exports.serverCollection = collectionInterface.extend4000({
    initialize: function(){
      var c, name, broadcast, parsePermissions, permissions, this$ = this;
      c = this.c = this.get('collection');
      this.permissions = {};
      this.set({
        name: name = c.get('name')
      });
      broadcast = this.get('broadcast');
      if (broadcast === true || broadcast === '*') {
        broadcast = {
          update: true,
          remove: true,
          create: true
        };
      }
      if (broadcast) {
        if (broadcast.update) {
          this.c.on('update', function(data){
            var id;
            if (id = data.id) {
              return this$.parent.parent.channel(name + ":" + id).broadcast({
                action: 'update',
                update: data
              });
            }
          });
        }
        if (broadcast.remove) {
          this.c.on('remove', function(data){
            var id;
            if (id = data.id) {
              return this$.parent.parent.channel(name + ":" + id).broadcast({
                action: 'remove'
              });
            }
          });
        }
        if (broadcast.create) {
          this.c.on('create', function(data){
            return this$.parent.parent.channel(name).broadcast({
              action: 'create',
              create: data
            });
          });
        }
      }
      parsePermissions = function(permissions){
        var def, keys;
        if (permissions) {
          def = false;
        } else {
          def = true;
        }
        keys = {
          find: true,
          findOne: true,
          call: true,
          create: true,
          remove: true,
          update: true
        };
        return h.dictMap(keys, function(val, key){
          var permission, x;
          permission = permissions[key];
          switch (x = permission != null ? permission.constructor : void 8) {
          case undefined:
            return def;
          case Boolean:
            return permission;
          case Object:
            return h.dictMap(permission, function(value, key){
              if (key !== 'chew') {
                return v(value);
              } else {
                return value;
              }
            });
          }
        });
      };
      if (!(permissions = this.get('permissions'))) {
        console.warn("WARNING: no permissions for collection " + name);
      }
      this.permissions = parsePermissions(permissions);
      return this.when('parent', function(parent){
        return parent.parent.onQuery({
          collection: name
        }, function(msg, res, realm){
          var ref$;
          realm == null && (realm = {});
          if (msg.create) {
            return this$.applyPermission(this$.permissions.create, {
              create: msg.create,
              postCreate: {}
            }, realm, function(err, msg){
              var modelClass, newModel, this$ = this;
              if (err) {
                return res.end({
                  err: 'access denied to collection: ' + err
                });
              }
              modelClass = c.resolveModel(msg.create);
              newModel = new modelClass();
              return newModel.update(msg.create, realm, function(err, data){
                if (err) {
                  return callbackToQuery(res)(err);
                }
                newModel.set(msg.postCreate);
                return newModel.flush(callbackToQuery(res));
              });
            });
          }
          if (msg.remove) {
            return this$.applyPermission(this$.permissions.remove, msg, realm, function(err, msg){
              if (err) {
                return res.end({
                  err: 'access denied to collection: ' + err
                });
              }
              this$.log('remove', msg.remove);
              return c.removeModel(msg.remove, realm, callbackToQuery(res));
            });
          }
          if (msg.findOne) {
            return this$.applyPermission(this$.permissions.findOne, msg, realm, function(err, msg){
              if (err) {
                return res.end({
                  err: 'access denied to collection: ' + err
                });
              }
              this$.log('findOne', msg.findOne);
              return c.findModel(msg.findOne, function(err, model){
                if (err || !model) {
                  return callbackToQuery(res)(err);
                }
                return model.render(realm, callbackToQuery(res));
              });
            });
          }
          if (msg.call && ((ref$ = msg.pattern) != null ? ref$.constructor : void 8) === Object) {
            return this$.applyPermission(this$.permissions.call, msg, realm, function(err, msg){
              if (err) {
                return res.end({
                  err: 'access denied to collection: ' + err
                });
              }
              this$.log('call', msg, msg.call);
              return c.fcall(msg.call, msg.args || [], msg.pattern, realm, callbackToQuery(res), function(err, data){
                if (err != null && err.name) {
                  err = err.name;
                }
                return res.end({
                  err: err,
                  data: data
                });
              });
            });
          }
          if (msg.update && msg.data) {
            return this$.applyPermission(this$.permissions.update, msg, realm, function(err, msg){
              var queue;
              if (err) {
                return res.end({
                  err: 'access denied to collection: ' + err
                });
              }
              this$.log('update', msg.update, msg.data);
              queue = new helpers.queue({
                size: 3
              });
              return c.findModels(msg.update, {}, function(err, model){
                return queue.push(model.id, function(callback){
                  var this$ = this;
                  return model.update(msg.data, realm, function(err, data){
                    if (err) {
                      return callback(err, data);
                    }
                    return model.flush(function(err, fdata){
                      var data;
                      if (!_.keys(data).length) {
                        data = undefined;
                      }
                      return callback(err, data);
                    });
                  });
                });
              }, function(){
                return queue.done(callbackToQuery(res));
              });
            });
          }
          if (msg.find) {
            return this$.applyPermission(this$.permissions.find, msg, realm, function(err, msg){
              var bucket, endCb;
              if (err) {
                return res.end({
                  err: 'access denied to collection: ' + err
                });
              }
              bucket = new helpers.parallelBucket();
              endCb = bucket.cb();
              this$.log('find', msg.find, msg.limits);
              c.findModels(msg.find, msg.limits || {}, function(err, model){
                var bucketCallback;
                bucketCallback = bucket.cb();
                return model.render(realm, function(err, data){
                  if (!err && !_.isEmpty(data)) {
                    res.write(data);
                  }
                  return bucketCallback();
                });
              }, function(err, data){
                return endCb();
              });
              return bucket.done(function(err, data){
                return res.end();
              });
            });
          }
          return res.end({
            err: 'wat'
          });
        });
      });
    },
    applyPermission: function(permission, msg, realm, cb){
      var waterfall, x, checkRealm, checkValue, checkChew;
      waterfall = {
        msg: msg
      };
      switch (x = permission != null ? permission.constructor : void 8) {
      case undefined:
        return cb("No permission");
      case Boolean:
        if (permission) {
          return cb(void 8, msg);
        } else {
          return cb("Explicitly Forbidden");
        }
        break;
      case Object:
        checkRealm = function(realm, cb){
          if (permission.realm != null) {
            return permission.realm.feed(realm, cb);
          } else {
            return _.defer(cb);
          }
        };
        checkValue = function(msg, cb){
          if (permission.value != null) {
            return permission.value.feed(msg, cb);
          } else {
            return _.defer(function(){
              return cb(void 8, msg);
            });
          }
        };
        checkChew = function(msg, realm, cb){
          if (permission.chew != null) {
            return permission.chew(msg, realm, cb);
          } else {
            return _.defer(function(){
              return cb(void 8, msg);
            });
          }
        };
        return checkRealm(realm, function(err, data){
          if (err) {
            return cb("Realm Access Denied");
          }
          return checkValue(msg, function(err, msg){
            if (err) {
              return cb("Value Access Denied");
            }
            return checkChew(msg, realm, function(err, msg){
              if (err) {
                return cb("Chew Access Denied");
              }
              return cb(void 8, msg);
            });
          });
        });
      }
    },
    applyPermission_: function(permissions, msg, realm, callback){
      permissions == null && (permissions = []);
      if (!permissions.length) {
        return callback("Access Denied");
      }
      return async.series(_.map(permissions, function(permission){
        return function(callback){
          return permission.matchMsg.feed(msg, function(err, msg){
            if (err) {
              return callback(null, err);
            }
            if (!permission.matchRealm) {
              return callback(msg);
            } else {
              return permission.matchRealm.feed(realm, function(err){
                if (err) {
                  return callback(null, err);
                } else {
                  return callback(msg);
                }
              });
            }
          });
        };
      }), function(data, err){
        if (data) {
          return callback(null, data);
        } else {
          return callback(true, data);
        }
      });
    }
  });
  server = exports.server = collectionProtocol.extend4000({
    defaults: {
      name: 'collectionServer',
      collectionClass: serverCollection
    },
    requires: [channel.server]
  });
  serverServer = exports.serverServer = collectionProtocol.extend4000({
    defaults: {
      name: 'collectionServerServer',
      collectionClass: serverCollection
    },
    requires: [query.serverServer],
    initialize: function(){
      var this$ = this;
      return this.when('parent', function(parent){
        parent.on('connect', function(client){
          return client.addProtocol(new server({
            verbose: this$.verbose,
            core: this$,
            logger: this$.logger
          }));
        });
        return _.map(parent.clients, function(client, id){
          return client.addProtocol(new server({
            verbose: this$.verbose,
            core: this$,
            logger: this$.logger
          }));
        });
      });
    }
  });
}).call(this);
